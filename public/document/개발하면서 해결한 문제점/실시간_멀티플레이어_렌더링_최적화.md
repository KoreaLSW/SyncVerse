# 실시간 멀티플레이어 환경에서의 렌더링 성능 최적화

이 문서는 실시간 멀티플레이어 환경에서 다수의 캐릭터가 동시에 이동할 때 발생하는 리렌더링 문제와 이를 해결하기 위한 기술적 최적화 과정을 정리한 문서입니다.

## 1. 개요 (Introduction)
*   **목적**: 실시간 멀티플레이어 환경에서 수십 명의 캐릭터가 동시에 이동할 때 발생하는 성능 저하를 해결하고, 끊김 없는(60FPS) 사용자 경험을 제공함.
*   **주요 과제**: React의 상태 기반 렌더링 방식과 고빈도(High-frequency) 좌표 업데이트 간의 충돌 해결.

## 2. 문제 상황 (Problem Identification)
*   **현상**:
    1. 캐릭터가 이동할 때마다 `MapCanvas`와 `Character` 컴포넌트가 초당 60회 이상 리렌더링됨.
    2. 하나의 캐릭터만 움직여도 전체 플레이어 리스트(`allPlayers`) 상태가 변경되어 모든 `Character` 컴포넌트가 다시 그려짐.
    3. 개발자 도구의 콘솔이 리렌더링 로그로 가득 차며, 저사양 기기에서 프레임 드랍 발생.
*   **원인**:
    *   **고빈도 업데이트**: 좌표(x, y) 데이터를 React State(`useState`)로 관리하여, 변경 시마다 Virtual DOM 비교(Reconciliation)가 발생함.
    *   **상태 전파**: 부모 컴포넌트(`MapCanvas`)에서 상태를 관리함에 따라 자식 컴포넌트들이 불필요하게 영향을 받음.

## 3. 최적화 전략 및 구현 (Implementation Strategy)

### 3.1 하이브리드 렌더링 (Hybrid Rendering)
React의 선언적 UI 관리와 직접적인 DOM 조작을 결합했습니다.
*   **구현**: 좌표 데이터를 React State에서 분리하고 `useRef`를 사용하여 플레이어의 DOM 요소를 직접 참조했습니다.
*   **효과**: 좌표 변경 시 React의 렌더링 사이클을 타지 않고 브라우저가 직접 위치를 업데이트하도록 하여 연산량을 획기적으로 줄였습니다.

### 3.2 requestAnimationFrame (RAF) 활용
*   **구현**: `MapCanvas`에서 `requestAnimationFrame` 루프를 실행하여, 각 프레임마다 최신 좌표를 DOM에 반영(style.transform)했습니다.
*   **코드 예시**:
    ```javascript
    const update = () => {
      // 1. 카메라 팔로우 로직
      // 2. 각 캐릭터의 x, y 좌표를 style.transform에 직접 반영
      animationFrameId = requestAnimationFrame(update);
    };
    ```

### 3.3 메타데이터 기반 리렌더링 제어 (Metadata Versioning)
*   **구현**: 캐릭터의 위치(x, y)와 실제 속성(닉네임, 색상, 방향 등)을 분리했습니다. `metadataVersion`이라는 상태를 두어, 실제 속성이 바뀔 때만 React 리렌더링을 트리거하도록 설계했습니다.
*   **효과**: 좌표가 아무리 변해도 캐릭터의 외형이나 정보가 바뀌지 않으면 컴포넌트는 단 한 번만 렌더링됩니다.

### 3.4 캐릭터 애니메이션 최적화
*   **구현**: `Character` 내부의 발 구르기 애니메이션(`frameIndex`) 역시 `useState` 대신 직접 DOM의 `backgroundPosition`을 수정하는 방식으로 변경했습니다.
*   **효과**: 0.1초마다 발생하는 애니메이션 업데이트가 컴포넌트 리렌더링을 유발하지 않습니다.

### 3.5 데이터 전송 최적화 (Throttling)
*   **구현**: 서버(Yjs/Hocuspocus)로 전송하는 위치 데이터의 빈도를 40ms(초당 25회)로 제한(Throttling)했습니다.
*   **효과**: 불필요한 네트워크 트래픽을 줄이고 서버 부하를 최소화하면서도 사용자에게는 부드러운 움직임을 제공합니다.

## 4. 결과 및 비교 (Results)
*   **리렌더링 횟수**: 초당 60회 이상 → **상태 변경(정지/시작/속성변경) 시에만 발생 (거의 0회)**.
*   **성능 향상**: CPU 점유율이 눈에 띄게 감소하였으며, 다수의 유저가 접속해도 부드러운 이동이 가능해짐.
*   **서버 효율**: 데이터 전송 주기 최적화를 통해 서버가 처리해야 할 패킷 양을 약 60% 절감.

## 5. 결론 및 배운 점 (Key Takeaways)
1. **적합한 도구 선택**: 모든 것을 React State로 관리하는 것이 항상 정답은 아니며, 게임과 같이 고성능이 필요한 영역에서는 직접적인 DOM 제어가 강력한 도구가 될 수 있음을 배움.
2. **관심사 분리**: 데이터의 성격(빈번한 변화 vs 구조적 변화)에 따라 렌더링 전략을 다르게 가져가는 설계 능력을 배양함.
3. **사용자 경험(UX)**: 기술적 최적화가 곧 부드러운 인터랙션과 직결됨을 실감함.

---
**작성일**: 2026-01-04
**작성자**: SyncVerse 개발팀

